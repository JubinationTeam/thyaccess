'use strict'
const EventEmitter = require('events');


// function to instantiate
function init(initVar){
    if(typeof initVar === "object"&&typeof initVar.globalEmitter === "object"&&initVar.globalEmitter instanceof EventEmitter&&typeof initVar.nextCall === "string"){
            initVar.globalEmitter.on(initVar.nextCall,dataAccessPlan)
    }
    else{
        console.log("Initialization of Data Access Failed due to improper parameters...")
    }
}


// catches events based on the request and executes the required db operation
function dataAccessPlan(model)
{          
    if(model&&model instanceof EventEmitter){
        if(model.dbOpsType){
            switch (model.dbOpsType)
                    {
                case "create" :
                            model.once("create", listenerCreate)
                            break;
                case "delete" :
                            model.once("delete", listenerDelete)
                            break;
                case "read" :
                            model.once("read", listenerReadByFilter)
                            break;
                case "update":
                            model.once("update", listenerUpdate)
                            break;
                case "readById":
                            model.once("readById", listenerReadById)
                            break;
                default:
                    
                            failedValidation(model,"Wrong ops type (supports create, read, readById, delete) : ops type sent is "+model.dbOpsType)
            }
        }
        else{
           failedValidation(model,"Model dbOps type undefined ")
        }
    }
    else{
        
            failedValidation(model,"Model undefined")
    }
  }

// function to create a new user
function listenerCreate(model){ 
    if(typeof model.schema === "function" &&typeof model.data=== "object" ){
        new model.schema(model.data).save((err,doc)=>{postDb(this,err,doc)});
    }
    else{
        failedValidation(model,"Model data incomplete");
    }
}

// function to delete a user by id
function listenerDelete(model){
    
    if(typeof model.schema === "function" &&model.id){
        model.schema.findByIdAndRemove(model.id,(err,doc)=>{postDb(this,err,doc)});
    }
    else{
        failedValidation(model,"Model data incomplete");
    }
}

// function to read user data by user's data
function listenerReadByFilter(model){
    if(typeof model.schema === "function" ){//&&typeof model.readLimit=== "number" && typeof model.offset=== "number"){
        model.schema.find(model.data,(err,doc)=>{postDb(this,err,doc)}).limit(model.readLimit).skip(model.offset);
    }
    else{
        failedValidation(model,"Model data incomplete");
    }
    
}

// function to read user data by user's id
function listenerReadById(model){
    if(typeof model.schema === "function" &&model.id){
        model.schema.findById(model.id,(err,doc)=>{postDb(this,err,doc)});
    }
    else{
        failedValidation(model,"Model data incomplete");
    }
}

//function to update user data
function listenerUpdate(model){
   if(typeof model.schema === "function" &&typeof model.data=== "object" &&model.id){ 
        model.schema.findByIdAndUpdate(model.id, { $set: model.data},(err,doc)=>{postDb(this,err,doc)})
   }
    else{
        failedValidation(model,"Model data incomplete");
    }
}

//failed validation response
function failedValidation(model,message){
    model.status=message;
    console.log(message)
    model.emit(model.callBackFromDataAccess,model);
}

//function to run after DB operation
function postDb(model,err,doc){
        if(err){
            console.log(err)
            model.status=err
        }
        else{
            
            model.status=doc
        }
        model.emit(model.callBackFromDataAccess,model);
}


// exports
module.exports=init;
